ZIP		- 5
TITLE	- Design of the Zerg Compiler (initial)
AUTHOR	- cmj<cmj@cmj.tw>
STATUS	- Activate
UPDATE	- 2017/05/27

# 簡介 #
Zerg 是一個設計出來練手的編譯器：預期中的功能是一個可編譯的程式語言，內建 *compile*
函數可以當作是即時編譯 (JIT, Just-in-time) 的入口點，也就是透過 compile 函數輸入程式碼，
並產生出可執行的機械碼。如果直接將結果寫入到檔案，則可以產生出一個可執行的檔案。
在最終目標中，Zerg 可以同時當編譯器與直譯器使用。

為了產生上述的功能，Zerg 本身需要具備所有基本編譯器的能力，也就是預處理 (Preprocessor)、
掃描 (Scanner)、解析 (Parser)、最佳化 (Optimization)、代碼產生 (Code Generation)。
在這一份 ZIP 中主要描述其中的兩個階段：掃描與解析。


## 掃描 (Scanner) ##
Scanner 又稱為語法分析器 (lexer)，主要用來判斷輸入的程式碼是否符合詞句規則並轉換成若干字詞
(token)。在 Zerg 中使用井字號 (#, hashtag) 當作是註解的開頭並視為單行註解，額外的規則如下：

	1. 註解開頭為井字號 (#, hashtag) 並結束在當行結尾
	2. 數字為 0-9 開頭的符號
		2.1 浮點數為特殊的數學字詞，其中最多含有一個點 (., dot)
		2.2 科學記號是一個特殊的數學字詞，其表示為 *[+-]浮點數[eE][+-]數字*
		2.3 接受十進位 (Decimal)、十六進位 (Hexadecimal)、八進位 (Octal) 與二進位 (Binary)
	3. 字串為單引號 (single quotes) 或雙引號 (double quotes) 為開頭結尾且可包含空白字元
	4. 運算符號請參考運算符號章節
	5. 縮排符號預設使用 tab (0x09, 水平定位符號)
	6. 所有非數字開頭且不包含空白字元、運算符號的字詞，都視為合法符號


### 運算符號 ###
在 Zerg 中使用白名單來判斷運算符號，其中以下為所有的運算符號表：

	| Symbol   | Usage     | Symbol   | Usage     | Symbol   | Usage     |
	|==========|===========|==========|===========|==========|===========|
	|   +      | 加號/正號 |   -      | 減號/負號 |   *      |  乘號     |
	|----------|-----------|----------|-----------|----------|-----------|
	|   /      |  除號     |   %      |  同餘     |   **     |  次方     |
	|----------|-----------|----------|-----------|----------|-----------|
	|   ++     |  遞增     |   --     |  遞減     |   ~      | 相似/補數 |
	|----------|-----------|----------|-----------|----------|-----------|
	|   <<     |  位元左疑 |   >>     |  位元右移 |   .      |  物件取值 |
	|----------|-----------|----------|-----------|----------|-----------|
	|   <      |  小於     |   >      |  大於     |   &      |  位元和   |
	|----------|-----------|----------|-----------|----------|-----------|
	|   |      |  位元或   |   ^      |  位元異或 |   =      |  左賦值   |
	|----------|-----------|----------|-----------|----------|-----------|
	|   ->     |  右賦值   |   .      |  物件取值 |   ,      |  多重陳述 |
	|----------|-----------|----------|-----------|----------|-----------|
	|   :      |  縮排語句 |   ;      |  陳述結尾 |          |           |
	|----------|-----------|----------|-----------|----------|-----------|


## 解析 (Parser) ##
從掃瞄器 (Scanner) 中獲得一連串合法的字詞之後，在這個階段會呼叫多個解析器來產生不同的產物，
最終用來產生可執行的代碼。一開始會先將字詞轉換成一個抽象語法樹 (AST, Abstract Syntax Tree)
，之後再轉換包含若干 AST 的流程圖 (CFG, Control Flow Graph) 用來描述程式碼區塊的轉換邏輯。
AST 是用來將輸入的原始碼轉換成一個不會有歧義 (Ambiguity) 的表達式，並藉由這個分析、
處理這個語法樹並轉換成控制流程圖。最後根據這個 CFG 來產生相對的代碼：在 Zerg 中是轉換成 IR
。在分析的過程中會經過若干步驟：

	1. 建立語法分析器
	2. 產生抽象語法樹
	3. 建立流程控制圖


### 語法分析器 ###
透過 *狀態 : 規則* 來表示一個語法規則，每一個規則都代表在有限狀態機 (DFA) 的轉換規則，
藉由分析語法規則，可以得到一個有限狀態機。一個有效的語法可以包含以下幾種形式：

	0. S : a              - F(I, a) = S
	1. S : E and E : a    - F(S, a) = E
	2. S : Ea             - F(E, a) = S
	3. S : aS             - F(S, a) = S
	4. S : aEb            - F(I, a) = E and F(E, b) = S

在 Zerg 中使用手寫 (handmade) 的 LL(1) 分析器來處理 DFA 的問題：實作若干函數來處理各種狀態
，每一個狀態都藉由分析當下與最多前一個字詞 (也就是 LL(1) 分析演算法) 來決定下一個狀態為何。
過程中同時也會產生相對的抽象語法樹。當輸入的語句透過 DFA 判斷是一個合法語句時，會產生一個
AST。所有合法語句會合成一個大的抽象語法樹。



### 抽象語法樹 (AST, Abstract Syntax Tree) ##
透過語法分析器處理後的字詞可產生一個AST：透過語法分析器提供的有限狀態機判斷狀態間的轉移，
建構抽象語法樹。例如一個輸入的句子為 *-1 - 2 - +3 % 4*，透過語法分析器來生成一個抽象語法樹
：在各判斷式中會生成屬於自己的抽象語法樹並最終結合成一個完整的抽象語法樹，如下表所表示的，
根據輸入的順序可以得到每個輸入值所使用到的判斷式：

	factor     arith | factor '%' arith
	arith      term  | arith  ( '+' | '-' ) term
	term       atom  | ( '+' | '-' ) atom
	atom       NUMBER

	       |  -   |   1   |   -   |   2   |   -   |   +   |  3   |   %   |   4   |
	==============================================================================
	init   |      |       |       |       |       |       |      |       |       |
	factor |      |       |       |       |       |       |      |   √   |       |
	arith  |      |       |   √   |       |   √   |       |      |       |       |
	term   |  √   |       |       |       |       |   √   |      |       |       |
	atom   |      |   √   |       |   √   |       |       |  √   |       |   √   |

	|  term  |   atom   |     arith     |    factor    |           AST           |
	|========|==========|===============|==============|=========================|
	|   +    |  NUMBER  |       +       |      %       |             -           |
	|   |    |          |    /    \     |    /   \     |           /   \         |
	| atom   |          |  term    term | arith  arith |         /      \        |
	|        |          |               |              |       -          %      |
	|   -    |          |       -       |              |     /   \      /   \    |
	|   |    |          |    /     \    |              |    -     2    +     4   |
	| atom   |          |  term    term |              |    |          |         |
	|        |          |               |              |    1          3         |



### 流程控制圖 (CFG, Control Flow Graph) ###
一個完整抽象語法樹的內容可能包含多個流程跳轉，這代表部分的語法有機會多次執行或條件執行，
因此將一個大的抽象語法樹拆成若干較小的抽象語法樹是必要的。用流程控制圖 (Control Flow Graph)
來描述不同語法樹之間的轉換關係，包含條件判斷 (condition) 跟 子程序呼叫 (sub-routine call)
兩種，分別代表著不同的使用情境。



### 編譯：從 AST 到 IR ###
獲得流程控制圖之後，就可以從一開始的狀態開始依序編譯成中介語言 (IR)。原則上每一個抽象語法樹
，都可以產生相對子程序 (sub-routine) 的 IR 並藉由已知的控制方式來決定子程序之間如何轉換。
每一個子程序所包含的抽象語法樹都可映射到特定的 IR 程式碼，子程序之間式也有固定的轉換方式，
因此每一個 CFG 都可以映射到特地的 IR 語法中。對於每一個抽象語法樹都可以分為以下若干幾種行為
，每一種行為都對應到特定的 IR 語法：

	0. 初始 IR - 定義程式進入點
	1. 數值運算
	2. 變數取值、寫入
	3. 條件判斷、改變流程、子程序呼叫
	4. 系統中斷
	5. 定義常數、符號表



# vim: set ft=markdown:

