ZIP		- 5
TITLE	- Design of the Zerg Compiler (initial)
AUTHOR	- cmj<cmj@cmj.tw>
STATUS	- Activate
UPDATE	- 2017/05/27

# 簡介 #
Zerg 是一個設計出來練手的編譯器：預期中的功能是一個編譯的程式語言，內建 *compile*
函數可以當作是即時編譯 (JIT, Just-in-time) 的入口點，也就是透過 compile 函數可輸入程式碼，
並且產生出可執行的機械碼。如果直接將結果寫入到檔案，則可以產生出一個可執行的檔案。
在最終目標中，Zerg 可以同時當編譯器與直譯器使用。

為了產生上述的功能，Zerg 本身需要具備所有基本編譯器的能力，也就是預處理 (Preprocessor)、
掃描 (Scanner)、解析 (Parser)、最佳化 (Optimization)、代碼產生 (Code Generation)。
在這一份 ZIP 中主要描述其中的兩個階段：掃描與解析。


## 掃描 (Scanner) ##
Scanner 又稱為語法分析器 (lexer)，主要用來判斷輸入的程式碼是否符合詞句規則並轉換成若干字詞
(Token)。在 Zerg 中使用井字號 (#, hashtag) 來當作是註解的開頭並視為單行註解，
額外的字詞規則如下：

	1. 註解開頭為井字號 (#, hashtag) 並結束在當行結尾
	2. 數字為 0-9 開頭的符號
		2.1 浮點數為特殊的數學字詞，其中最多含有一個點 (., dot)
		2.2 科學記號是一個特殊的數學字詞，其表示為 *[+-]浮點數[eE][+-]數字*
		2.3 接受十進位 (Decimal)、十六進位 (Hexadecimal)、八進位 (Octal) 與二進位 (Binary)
	3. 字串為單引號 (single quotes) 或雙引號 (double quotes) 為開頭結尾且可包含空白字元
	4. 運算符號請參考運算符號章節
	5. 縮排符號預設使用 Tab (0x09, 水平定位符號)
	6. 所有非數字開頭且不包含空白字元、運算符號的字詞，都視為合法符號


### 運算符號 ###
在 Zerg 中使用白名單來判斷運算福號，其中以下為所有的運算符號表：

	| Symbol   | Usage     | Symbol   | Usage     | Symbol   | Usage     |
	|==========|===========|==========|===========|==========|===========|
	|   +      | 加號/正號 |   -      | 減號/負號 |   *      |  乘號     |
	|----------|-----------|----------|-----------|----------|-----------|
	|   /      |  除號     |   %      |  同餘     |   **     |  次方     |
	|----------|-----------|----------|-----------|----------|-----------|
	|   ++     |  遞增     |   --     |  遞減     |   ~      | 相似/補數 |
	|----------|-----------|----------|-----------|----------|-----------|
	|   <<     |  位元左疑 |   >>     |  位元右移 |   .      |  物件取值 |
	|----------|-----------|----------|-----------|----------|-----------|
	|   <      |  小於     |   >      |  大於     |   &      |  位元和   |
	|----------|-----------|----------|-----------|----------|-----------|
	|   |      |  位元或   |   ^      |  位元異或 |   =      |  左賦值   |
	|----------|-----------|----------|-----------|----------|-----------|
	|   ->     |  右賦值   |          |           |          |           |
	|----------|-----------|----------|-----------|----------|-----------|


## 解析 (Parser) ##
從掃瞄器 (Scanner) 中獲得一連串合法的字詞之後，在這個階段會呼叫多個解析器來產生不同的產物，
最終用來產生可執行的代碼。一開始會先將字詞轉換成一個抽象語法樹 (AST, Abstract Syntax Tree)
，之後再轉換包含若干 AST 的流程圖 (CFG, Control Flow Graph) 用來描述程式碼區塊間的轉換邏輯
。AST 是用來將輸入的原始碼，轉換成一個不會有歧義 (Ambiguity) 的表達式，並藉由這個分析、
處理這個語法樹轉換成控制流程圖。最後根據這個 CFG 來產生相對的代碼：在 Zerg 中是轉換成 IR。


### 解析樹 (Parse Tree) ###

### 抽象語法樹 (AST, Abstract Syntax Tree) ##

### 流程控制圖 (CFG, Control Flow Graph) ###

### 編譯：從 CFG 到 IR ###

# vim: set ft=markdown:

